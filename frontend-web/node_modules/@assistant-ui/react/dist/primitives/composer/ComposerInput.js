"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import { composeEventHandlers } from "@radix-ui/primitive";
import { useComposedRefs } from "@radix-ui/react-compose-refs";
import { Slot } from "@radix-ui/react-slot";
import { forwardRef, useCallback, useEffect, useRef, } from "react";
import TextareaAutosize from "react-textarea-autosize";
import { useEscapeKeydown } from "@radix-ui/react-use-escape-keydown";
import { useOnScrollToBottom } from "../../utils/hooks/useOnScrollToBottom.js";
import { useAuiState, useAui } from "@assistant-ui/store";
import { flushResourcesSync } from "@assistant-ui/tap";
/**
 * A text input component for composing messages.
 *
 * This component provides a rich text input experience with automatic resizing,
 * keyboard shortcuts, file paste support, and intelligent focus management.
 * It integrates with the composer context to manage message state and submission.
 *
 * @example
 * ```tsx
 * // Ctrl/Cmd+Enter to submit (plain Enter inserts newline)
 * <ComposerPrimitive.Input
 *   placeholder="Type your message..."
 *   submitMode="ctrlEnter"
 * />
 *
 * // Old API (deprecated, still supported)
 * <ComposerPrimitive.Input
 *   placeholder="Type your message..."
 *   submitOnEnter={true}
 * />
 * ```
 */
export const ComposerPrimitiveInput = forwardRef(({ autoFocus = false, asChild, disabled: disabledProp, onChange, onKeyDown, onPaste, submitOnEnter, submitMode, cancelOnEscape = true, unstable_focusOnRunStart = true, unstable_focusOnScrollToBottom = true, unstable_focusOnThreadSwitched = true, addAttachmentOnPaste = true, ...rest }, forwardedRef) => {
    const aui = useAui();
    const effectiveSubmitMode = submitMode ?? (submitOnEnter === false ? "none" : "enter");
    const value = useAuiState((s) => {
        if (!s.composer.isEditing)
            return "";
        return s.composer.text;
    });
    const Component = asChild ? Slot : TextareaAutosize;
    const isDisabled = useAuiState((s) => s.thread.isDisabled || s.composer.dictation?.inputDisabled) || disabledProp;
    const textareaRef = useRef(null);
    const ref = useComposedRefs(forwardedRef, textareaRef);
    useEscapeKeydown((e) => {
        if (!cancelOnEscape)
            return;
        // Only handle ESC if it originated from within this input
        if (!textareaRef.current?.contains(e.target))
            return;
        const composer = aui.composer();
        if (composer.getState().canCancel) {
            composer.cancel();
            e.preventDefault();
        }
    });
    const handleKeyPress = (e) => {
        if (isDisabled)
            return;
        // ignore IME composition events
        if (e.nativeEvent.isComposing)
            return;
        if (e.key === "Enter" && !e.shiftKey) {
            const isRunning = aui.thread().getState().isRunning;
            if (isRunning)
                return;
            let shouldSubmit = false;
            if (effectiveSubmitMode === "ctrlEnter") {
                shouldSubmit = e.ctrlKey || e.metaKey;
            }
            else if (effectiveSubmitMode === "enter") {
                shouldSubmit = true;
            }
            if (shouldSubmit) {
                e.preventDefault();
                textareaRef.current?.closest("form")?.requestSubmit();
            }
        }
    };
    const handlePaste = async (e) => {
        if (!addAttachmentOnPaste)
            return;
        const threadCapabilities = aui.thread().getState().capabilities;
        const files = Array.from(e.clipboardData?.files || []);
        if (threadCapabilities.attachments && files.length > 0) {
            try {
                e.preventDefault();
                await Promise.all(files.map((file) => aui.composer().addAttachment(file)));
            }
            catch (error) {
                console.error("Error adding attachment:", error);
            }
        }
    };
    const autoFocusEnabled = autoFocus && !isDisabled;
    const focus = useCallback(() => {
        const textarea = textareaRef.current;
        if (!textarea || !autoFocusEnabled)
            return;
        textarea.focus({ preventScroll: true });
        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }, [autoFocusEnabled]);
    useEffect(() => focus(), [focus]);
    useOnScrollToBottom(() => {
        if (aui.composer().getState().type === "thread" &&
            unstable_focusOnScrollToBottom) {
            focus();
        }
    });
    useEffect(() => {
        if (aui.composer().getState().type !== "thread" ||
            !unstable_focusOnRunStart)
            return undefined;
        return aui.on("thread.runStart", focus);
    }, [unstable_focusOnRunStart, focus, aui]);
    useEffect(() => {
        if (aui.composer().getState().type !== "thread" ||
            !unstable_focusOnThreadSwitched)
            return undefined;
        return aui.on("threadListItem.switchedTo", focus);
    }, [unstable_focusOnThreadSwitched, focus, aui]);
    return (_jsx(Component, { name: "input", value: value, ...rest, ref: ref, disabled: isDisabled, onChange: composeEventHandlers(onChange, (e) => {
            if (!aui.composer().getState().isEditing)
                return;
            flushResourcesSync(() => {
                aui.composer().setText(e.target.value);
            });
        }), onKeyDown: composeEventHandlers(onKeyDown, handleKeyPress), onPaste: composeEventHandlers(onPaste, handlePaste) }));
});
ComposerPrimitiveInput.displayName = "ComposerPrimitive.Input";
//# sourceMappingURL=ComposerInput.js.map